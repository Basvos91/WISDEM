
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>drivese.drivese_utils &#8212; DriveSE 0.1.1 documentation</title>
    <link rel="stylesheet" href="../../_static/nrel.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="nav-item nav-item-0"><a href="../../index.html">DriveSE 0.1.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for drivese.drivese_utils</h1><div class="highlight"><pre>
<span></span><span class="c1"># Utility functions used by drivese components</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy</span> <span class="k">as</span> <span class="nn">scp</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="k">import</span> <span class="n">pi</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">log10</span><span class="p">,</span> <span class="n">log</span>

<span class="c1">#-------------------------------------------------------------------------</span>
<span class="c1"># Supporting functions</span>

<span class="c1">#If user does not specify key information about turbine properties,</span>
<span class="c1">#they are estimated from curve fits to basic turbine configuration parameters</span>

<span class="c1"># if user inputs forces and zero rotor mass then rotor mass estimated</span>
<div class="viewcode-block" id="get_rotor_mass"><a class="viewcode-back" href="../../documentation.html#drivese.drivese_utils.get_rotor_mass">[docs]</a><span class="k">def</span> <span class="nf">get_rotor_mass</span><span class="p">(</span><span class="n">machine_rating</span><span class="p">,</span> <span class="n">deriv</span><span class="p">):</span>  
    <span class="n">out</span> <span class="o">=</span> <span class="p">[</span><span class="mf">23.566</span> <span class="o">*</span> <span class="n">machine_rating</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">deriv</span><span class="p">:</span>
        <span class="n">out</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="mf">23.566</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">out</span></div>

<span class="c1"># moments taken to scale approximately with force (rotor mass) and distance (distance_hub2mb)</span>
<span class="k">def</span> <span class="nf">get_My</span><span class="p">(</span><span class="n">rotor_mass</span><span class="p">,</span> <span class="n">distance_hub2mb</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">distance_hub2mb</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># approximate rotor diameter from rotor mass</span>
        <span class="n">distance_hub2mb</span> <span class="o">=</span> <span class="n">get_distance_hub2mb</span><span class="p">((</span><span class="n">rotor_mass</span> <span class="o">+</span> <span class="mi">49089</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1170.6</span><span class="p">)</span>
    <span class="k">return</span> <span class="mf">59.7</span> <span class="o">*</span> <span class="n">rotor_mass</span> <span class="o">*</span> <span class="n">distance_hub2mb</span>

<span class="c1"># moments taken to scale roughly with force (rotor mass) and distance (distance_hub2mb)</span>
<span class="k">def</span> <span class="nf">get_Mz</span><span class="p">(</span><span class="n">rotor_mass</span><span class="p">,</span> <span class="n">distance_hub2mb</span><span class="p">):</span>  
    <span class="k">if</span> <span class="n">distance_hub2mb</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># approximate rotor diameter from rotor mass</span>
        <span class="n">distance_hub2mb</span> <span class="o">=</span> <span class="n">get_distance_hub2mb</span><span class="p">((</span><span class="n">rotor_mass</span> <span class="o">-</span> <span class="mi">49089</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1170.6</span><span class="p">)</span>
    <span class="k">return</span> <span class="mf">53.846</span> <span class="o">*</span> <span class="n">rotor_mass</span> <span class="o">*</span> <span class="n">distance_hub2mb</span>

<span class="c1"># function to estimate the location of the main bearing location from the hub center</span>
<span class="k">def</span> <span class="nf">get_distance_hub2mb</span><span class="p">(</span><span class="n">rotor_diameter</span><span class="p">,</span> <span class="n">deriv</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">out</span> <span class="o">=</span> <span class="mf">0.007835</span> <span class="o">*</span> <span class="n">rotor_diameter</span> <span class="o">+</span> <span class="mf">0.9642</span>
    <span class="c1"># Ignoring deriv calculation for now</span>
    <span class="c1">#if deriv:</span>
    <span class="c1">#    out.extend([.007835])</span>
    <span class="k">return</span> <span class="n">out</span>

<span class="c1"># -------------------------------------------------</span>
<span class="c1"># Bearing support functions</span>
<span class="c1"># returns FW, mass for bearings without fatigue analysis</span>
<div class="viewcode-block" id="resize_for_bearings"><a class="viewcode-back" href="../../documentation.html#drivese.drivese_utils.resize_for_bearings">[docs]</a><span class="k">def</span> <span class="nf">resize_for_bearings</span><span class="p">(</span><span class="n">D_shaft</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">deriv</span><span class="p">):</span>
    <span class="c1"># assume low load rating for bearing</span>
    <span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="s1">&#39;CARB&#39;</span><span class="p">:</span>  <span class="c1"># p = Fr, so X=1, Y=0</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">[</span><span class="n">D_shaft</span><span class="p">,</span> <span class="o">.</span><span class="mi">2663</span> <span class="o">*</span> <span class="n">D_shaft</span> <span class="o">+</span> <span class="o">.</span><span class="mi">0435</span><span class="p">,</span> <span class="mf">1561.4</span> <span class="o">*</span> <span class="n">D_shaft</span><span class="o">**</span><span class="mf">2.6007</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">deriv</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="o">.</span><span class="mi">2663</span><span class="p">,</span> <span class="mf">1561.4</span> <span class="o">*</span> <span class="mf">2.6007</span> <span class="o">*</span> <span class="n">D_shaft</span><span class="o">**</span><span class="mf">1.6007</span><span class="p">])</span>
    <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="s1">&#39;SRB&#39;</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">[</span><span class="n">D_shaft</span><span class="p">,</span> <span class="o">.</span><span class="mi">2762</span> <span class="o">*</span> <span class="n">D_shaft</span><span class="p">,</span> <span class="mf">876.7</span> <span class="o">*</span> <span class="n">D_shaft</span><span class="o">**</span><span class="mf">1.7195</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">deriv</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="o">.</span><span class="mi">2762</span><span class="p">,</span> <span class="mf">876.7</span> <span class="o">*</span> <span class="mf">1.7195</span> <span class="o">*</span> <span class="n">D_shaft</span><span class="o">**</span><span class="mf">0.7195</span><span class="p">])</span>
    <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="s1">&#39;TRB1&#39;</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">[</span><span class="n">D_shaft</span><span class="p">,</span> <span class="o">.</span><span class="mi">0740</span><span class="p">,</span> <span class="mf">92.863</span> <span class="o">*</span> <span class="n">D_shaft</span><span class="o">**.</span><span class="mi">8399</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">deriv</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">92.863</span> <span class="o">*</span> <span class="mf">0.8399</span> <span class="o">*</span> <span class="n">D_shaft</span><span class="o">**</span><span class="p">(</span><span class="mf">0.8399</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">)])</span>
    <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="s1">&#39;CRB&#39;</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">[</span><span class="n">D_shaft</span><span class="p">,</span> <span class="o">.</span><span class="mi">1136</span> <span class="o">*</span> <span class="n">D_shaft</span><span class="p">,</span> <span class="mf">304.19</span> <span class="o">*</span> <span class="n">D_shaft</span><span class="o">**</span><span class="mf">1.8885</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">deriv</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="o">.</span><span class="mi">1136</span><span class="p">,</span> <span class="mf">304.19</span> <span class="o">*</span> <span class="mf">1.8885</span> <span class="o">*</span> <span class="n">D_shaft</span><span class="o">**</span><span class="mf">0.8885</span><span class="p">])</span>
    <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="s1">&#39;TRB2&#39;</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">[</span><span class="n">D_shaft</span><span class="p">,</span> <span class="o">.</span><span class="mi">1499</span> <span class="o">*</span> <span class="n">D_shaft</span><span class="p">,</span> <span class="mf">543.01</span> <span class="o">*</span> <span class="n">D_shaft</span><span class="o">**</span><span class="mf">1.9043</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">deriv</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="o">.</span><span class="mi">1499</span><span class="p">,</span> <span class="mf">543.01</span> <span class="o">*</span> <span class="mf">1.9043</span> <span class="o">*</span> <span class="n">D_shaft</span><span class="o">**.</span><span class="mi">9043</span><span class="p">])</span>
    <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="s1">&#39;RB&#39;</span><span class="p">:</span>  <span class="c1"># factors depend on ratio Fa/C0, C0 depends on bearing... TODO: add this functionality</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">[</span><span class="n">D_shaft</span><span class="p">,</span> <span class="o">.</span><span class="mi">0839</span><span class="p">,</span> <span class="mf">229.47</span> <span class="o">*</span> <span class="n">D_shaft</span><span class="o">**</span><span class="mf">1.8036</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">deriv</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">229.47</span> <span class="o">*</span> <span class="mf">1.8036</span> <span class="o">*</span> <span class="n">D_shaft</span><span class="o">**</span><span class="mf">0.8036</span><span class="p">])</span>

    <span class="c1"># shaft diameter, FW, mass. if deriv==True, provides derivatives.</span>
    <span class="k">return</span> <span class="n">out</span></div>


<span class="c1"># Transform functions for rotor forces and moments (not currently used)</span>
<span class="c1"># ---------------------------------------------------------------------</span>
<span class="k">class</span> <span class="nc">blade_moment_transform</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Blade_Moment_Transform class          </span>
<span class="sd">          The Blade_Moment_Transform class is used to transform moments from the WISDEM rotor models to driveSE.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">blade_moment_transform</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="c1"># variables</span>
        <span class="c1"># ensure angles are in radians. Azimuth is 3-element array with blade</span>
        <span class="c1"># azimuths; b1, b2, b3 are 3-element arrays for each blade moment (Mx, My,</span>
        <span class="c1"># Mz); pitch and cone are floats</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_param</span><span class="p">(</span><span class="s1">&#39;azimuth_angle&#39;</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">]),</span> <span class="n">units</span><span class="o">=</span><span class="s1">&#39;rad&#39;</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;azimuth angles for each blade&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_param</span><span class="p">(</span><span class="s1">&#39;pitch_angle&#39;</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s1">&#39;rad&#39;</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;pitch angle at each blade, assumed same&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_param</span><span class="p">(</span><span class="s1">&#39;cone_angle&#39;</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s1">&#39;rad&#39;</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;cone angle at each blade, assumed same&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_param</span><span class="p">(</span><span class="s1">&#39;b1&#39;</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span> <span class="n">units</span><span class="o">=</span><span class="s1">&#39;N*m&#39;</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;moments in x,y,z directions along local blade coordinate system&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_param</span><span class="p">(</span><span class="s1">&#39;b2&#39;</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span> <span class="n">units</span><span class="o">=</span><span class="s1">&#39;N*m&#39;</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;moments in x,y,z directions along local blade coordinate system&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_param</span><span class="p">(</span><span class="s1">&#39;b3&#39;</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span> <span class="n">units</span><span class="o">=</span><span class="s1">&#39;N*m&#39;</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;moments in x,y,z directions along local blade coordinate system&#39;</span><span class="p">)</span>

        <span class="c1"># returns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_output</span><span class="p">(</span><span class="s1">&#39;Mx&#39;</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s1">&#39;N*m&#39;</span><span class="p">,</span>  <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;rotor moment in x-direction&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_output</span><span class="p">(</span><span class="s1">&#39;My&#39;</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s1">&#39;N*m&#39;</span><span class="p">,</span>  <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;rotor moment in y-direction&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_output</span><span class="p">(</span><span class="s1">&#39;Mz&#39;</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s1">&#39;N*m&#39;</span><span class="p">,</span>  <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;rotor moment in z-direction&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">solve_nonlinear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">unknowns</span><span class="p">,</span> <span class="n">resids</span><span class="p">):</span>

        <span class="c1"># nested function for transformations</span>
        <span class="k">def</span> <span class="nf">trans</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">con</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">bMx</span><span class="p">,</span> <span class="n">bMy</span><span class="p">,</span> <span class="n">bMz</span><span class="p">):</span>
            <span class="n">Mx</span> <span class="o">=</span> <span class="n">bMx</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">con</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">-</span> <span class="n">bMy</span> <span class="o">*</span> <span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">con</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">-</span> <span class="n">sin</span><span class="p">(</span>
                <span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">))</span> <span class="o">+</span> <span class="n">bMz</span> <span class="o">*</span> <span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">con</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">-</span> <span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">))</span>
            <span class="n">My</span> <span class="o">=</span> <span class="n">bMx</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">con</span><span class="p">)</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">-</span> <span class="n">bMy</span> <span class="o">*</span> <span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">con</span><span class="p">)</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">+</span> <span class="n">cos</span><span class="p">(</span>
                <span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">))</span> <span class="o">+</span> <span class="n">bMz</span> <span class="o">*</span> <span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">con</span><span class="p">)</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">+</span> <span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">))</span>
            <span class="n">Mz</span> <span class="o">=</span> <span class="n">bMx</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">))</span> <span class="o">-</span> <span class="n">bMy</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">*</span>
                                              <span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">))</span> <span class="o">+</span> <span class="n">bMz</span> <span class="o">*</span> <span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">))</span>

            <span class="k">return</span> <span class="p">[</span><span class="n">Mx</span><span class="p">,</span> <span class="n">My</span><span class="p">,</span> <span class="n">Mz</span><span class="p">]</span>

        <span class="p">[</span><span class="n">b1Mx</span><span class="p">,</span> <span class="n">b1My</span><span class="p">,</span> <span class="n">b1Mz</span><span class="p">]</span> <span class="o">=</span> <span class="n">trans</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pitch_angle</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cone_angle</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">azimuth_angle</span><span class="p">[</span>
                                   <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">b1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">b1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">b1</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="p">[</span><span class="n">b2Mx</span><span class="p">,</span> <span class="n">b2My</span><span class="p">,</span> <span class="n">b2Mz</span><span class="p">]</span> <span class="o">=</span> <span class="n">trans</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pitch_angle</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cone_angle</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">azimuth_angle</span><span class="p">[</span>
                                   <span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">b2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">b2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">b2</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="p">[</span><span class="n">b3Mx</span><span class="p">,</span> <span class="n">b3My</span><span class="p">,</span> <span class="n">b3Mz</span><span class="p">]</span> <span class="o">=</span> <span class="n">trans</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pitch_angle</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cone_angle</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">azimuth_angle</span><span class="p">[</span>
                                   <span class="mi">2</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">b3</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">b3</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">b3</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Mx</span> <span class="o">=</span> <span class="n">b1Mx</span> <span class="o">+</span> <span class="n">b2Mx</span> <span class="o">+</span> <span class="n">b3Mx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">My</span> <span class="o">=</span> <span class="n">b1My</span> <span class="o">+</span> <span class="n">b2My</span> <span class="o">+</span> <span class="n">b3My</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Mz</span> <span class="o">=</span> <span class="n">b1Mz</span> <span class="o">+</span> <span class="n">b2Mz</span> <span class="o">+</span> <span class="n">b3Mz</span>


<span class="k">class</span> <span class="nc">blade_force_transform</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Blade_Force_Transform class          </span>
<span class="sd">          The Blade_Force_Transform class is used to transform forces from the WISDEM rotor models to driveSE.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">blade_force_transform</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="c1"># variables</span>
        <span class="c1"># ensure angles are in radians. Azimuth is 3-element array with blade</span>
        <span class="c1"># azimuths; b1, b2, b3 are 3-element arrays for each blade force (Fx, Fy,</span>
        <span class="c1"># Fz); pitch and cone are floats</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_param</span><span class="p">(</span><span class="s1">&#39;azimuth_angle&#39;</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">]),</span> <span class="n">units</span><span class="o">=</span><span class="s1">&#39;rad&#39;</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;azimuth angles for each blade&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_param</span><span class="p">(</span><span class="s1">&#39;pitch_angle&#39;</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s1">&#39;rad&#39;</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;pitch angle at each blade, assumed same&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_param</span><span class="p">(</span><span class="s1">&#39;cone_angle&#39;</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s1">&#39;rad&#39;</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;cone angle at each blade, assumed same&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_param</span><span class="p">(</span><span class="s1">&#39;b1&#39;</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span> <span class="n">units</span><span class="o">=</span><span class="s1">&#39;N&#39;</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;forces in x,y,z directions along local blade coordinate system&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_param</span><span class="p">(</span><span class="s1">&#39;b2&#39;</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span> <span class="n">units</span><span class="o">=</span><span class="s1">&#39;N&#39;</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;forces in x,y,z directions along local blade coordinate system&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_param</span><span class="p">(</span><span class="s1">&#39;b3&#39;</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span> <span class="n">units</span><span class="o">=</span><span class="s1">&#39;N&#39;</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;forces in x,y,z directions along local blade coordinate system&#39;</span><span class="p">)</span>

        <span class="c1"># returns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_output</span><span class="p">(</span><span class="s1">&#39;Fx&#39;</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s1">&#39;N&#39;</span><span class="p">,</span>  <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;rotor force in x-direction&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_output</span><span class="p">(</span><span class="s1">&#39;Fy&#39;</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s1">&#39;N&#39;</span><span class="p">,</span>  <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;rotor force in y-direction&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_output</span><span class="p">(</span><span class="s1">&#39;Fz&#39;</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s1">&#39;N&#39;</span><span class="p">,</span>  <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;rotor force in z-direction&#39;</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">solve_nonlinear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">unknowns</span><span class="p">,</span> <span class="n">resids</span><span class="p">):</span>

        <span class="c1"># nested function for transformations</span>
        <span class="k">def</span> <span class="nf">trans</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">con</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">bFx</span><span class="p">,</span> <span class="n">bFy</span><span class="p">,</span> <span class="n">bFz</span><span class="p">):</span>
            <span class="n">Fx</span> <span class="o">=</span> <span class="n">bFx</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">con</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">-</span> <span class="n">bFy</span> <span class="o">*</span> <span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">con</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">-</span> <span class="n">sin</span><span class="p">(</span>
                <span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">))</span> <span class="o">+</span> <span class="n">bFz</span> <span class="o">*</span> <span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">con</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">-</span> <span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">))</span>
            <span class="n">Fy</span> <span class="o">=</span> <span class="n">bFx</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">con</span><span class="p">)</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">-</span> <span class="n">bFy</span> <span class="o">*</span> <span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">con</span><span class="p">)</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">+</span> <span class="n">cos</span><span class="p">(</span>
                <span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">))</span> <span class="o">+</span> <span class="n">bFz</span> <span class="o">*</span> <span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">con</span><span class="p">)</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">+</span> <span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">))</span>
            <span class="n">Fz</span> <span class="o">=</span> <span class="n">bFx</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">))</span> <span class="o">-</span> <span class="n">bFy</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">*</span>
                                              <span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">))</span> <span class="o">+</span> <span class="n">bFz</span> <span class="o">*</span> <span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">))</span>

            <span class="k">return</span> <span class="p">[</span><span class="n">Fx</span><span class="p">,</span> <span class="n">Fy</span><span class="p">,</span> <span class="n">Fz</span><span class="p">]</span>

        <span class="p">[</span><span class="n">b1Fx</span><span class="p">,</span> <span class="n">b1Fy</span><span class="p">,</span> <span class="n">b1Fz</span><span class="p">]</span> <span class="o">=</span> <span class="n">trans</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pitch_angle</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cone_angle</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">azimuth_angle</span><span class="p">[</span>
                                   <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">b1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">b1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">b1</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="p">[</span><span class="n">b2Fx</span><span class="p">,</span> <span class="n">b2Fy</span><span class="p">,</span> <span class="n">b2Fz</span><span class="p">]</span> <span class="o">=</span> <span class="n">trans</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pitch_angle</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cone_angle</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">azimuth_angle</span><span class="p">[</span>
                                   <span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">b2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">b2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">b2</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="p">[</span><span class="n">b3Fx</span><span class="p">,</span> <span class="n">b3Fy</span><span class="p">,</span> <span class="n">b3Fz</span><span class="p">]</span> <span class="o">=</span> <span class="n">trans</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pitch_angle</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cone_angle</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">azimuth_angle</span><span class="p">[</span>
                                   <span class="mi">2</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">b3</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">b3</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">b3</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Fx</span> <span class="o">=</span> <span class="n">b1Fx</span> <span class="o">+</span> <span class="n">b2Fx</span> <span class="o">+</span> <span class="n">b3Fx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Fy</span> <span class="o">=</span> <span class="n">b1Fy</span> <span class="o">+</span> <span class="n">b2Fy</span> <span class="o">+</span> <span class="n">b3Fy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Fz</span> <span class="o">=</span> <span class="n">b1Fz</span> <span class="o">+</span> <span class="n">b2Fz</span> <span class="o">+</span> <span class="n">b3Fz</span>

<span class="c1">#-------------------------------------------------------------------------</span>
<span class="c1"># Fatigue calculations supporting functions and code for low speed shaft and main bearing(s) (not currently used)</span>
<span class="c1"># Developed 2014 by Taylor Parsons - requires additional testing and development to complete</span>
<span class="c1">#-------------------------------------------------------------------------</span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd"># basic supporting functions</span>
<span class="sd">def Ninterp(S, a, b):</span>
<span class="sd">    return (S / a)**(1 / b)</span>

<span class="sd">def Goodman(S_alt, S_mean, Sut):</span>
<span class="sd">    return S_alt / (1 - (S_mean / Sut))</span>

<span class="sd">def standardrange(N, N_f, Beta, k_b):</span>
<span class="sd">    F_delta = (Beta * (log10(N_f) - log10(N))) + 0.18</span>
<span class="sd">    if F_delta &gt;= 2 * k_b:</span>
<span class="sd">        F_delta = 0.</span>
<span class="sd">    return F_delta</span>

<span class="sd"># calculate required dynamic load rating, C</span>
<span class="sd">def C_calc(F_a, F_r, N_array, p, e, Y1, Y2, X2, life_bearing):</span>
<span class="sd">    Fa_ref = np.max(F_a)  # used in comparisons Fa/Fr &lt;e</span>
<span class="sd">    Fr_ref = np.max(F_r)</span>

<span class="sd">    if Fa_ref / Fr_ref &lt;= e:</span>
<span class="sd">        P = F_r + Y1 * F_a</span>
<span class="sd">    else:</span>
<span class="sd">        P = X2 * F_r + Y2 * F_a</span>

<span class="sd">    P_eq = ((scp.integrate.simps((P**p), x=N_array, even=&#39;avg&#39;)) /</span>
<span class="sd">            (N_array[-1] - N_array[0]))**(1 / p)</span>
<span class="sd">    C_min = P_eq * (life_bearing / 1e6)**(1. / p) / 1000  # kN</span>
<span class="sd">    return C_min</span>

<span class="sd"># fatigue analysis for bearings</span>
<span class="sd">def fatigue_for_bearings(D_shaft, F_r, F_a, N_array, life_bearing, type, deriv):</span>
<span class="sd">    # deriv is boolean, defines if derivatives are returned</span>
<span class="sd">    if type == &#39;CARB&#39;:  # p = Fr, so X=1, Y=0</span>
<span class="sd">        if (np.max(F_a)) &gt; 0:</span>
<span class="sd">            print(&#39;---------------------------------------------------------&#39;)</span>
<span class="sd">            print(&quot;error: axial loads too large for CARB bearing application&quot;)</span>
<span class="sd">            print(&#39;---------------------------------------------------------&#39;)</span>
<span class="sd">        else:</span>
<span class="sd">            e = 1</span>
<span class="sd">            Y1 = 0.</span>
<span class="sd">            X2 = 1.</span>
<span class="sd">            Y2 = 0.</span>
<span class="sd">            p = 10. / 3</span>
<span class="sd">        C_min = C_calc(F_a, F_r, N_array, p, e, Y1, Y2, X2, life_bearing)</span>
<span class="sd">        if C_min &gt; 13980 * D_shaft**1.5602:</span>
<span class="sd">            out = [D_shaft, 0.4299 * D_shaft +</span>
<span class="sd">                   0.0382, 3682.8 * D_shaft**2.7676]</span>
<span class="sd">            if deriv:</span>
<span class="sd">                out.extend([1., 0.4299, 3682.8 * 2.7676 * D_shaft**1.7676])</span>
<span class="sd">        else:</span>
<span class="sd">            out = [D_shaft, .2663 * D_shaft + .0435, 1561.4 * D_shaft**2.6007]</span>
<span class="sd">            if deriv:</span>
<span class="sd">                out.extend([1., .2663, 1561.4 * 2.6007 * D_shaft**1.6007])</span>

<span class="sd">    elif type == &#39;SRB&#39;:</span>
<span class="sd">        e = 0.32</span>
<span class="sd">        Y1 = 2.1</span>
<span class="sd">        X2 = 0.67</span>
<span class="sd">        Y2 = 3.1</span>
<span class="sd">        p = 10. / 3</span>
<span class="sd">        C_min = C_calc(F_a, F_r, N_array, p, e, Y1, Y2, X2, life_bearing)</span>
<span class="sd">        if C_min &gt; 13878 * D_shaft**1.0796:</span>
<span class="sd">            out = [D_shaft, .4801 * D_shaft, 2688.3 * D_shaft**1.8877]</span>
<span class="sd">            if deriv:</span>
<span class="sd">                out.extend([1., .4801, 2688.3 * 1.8877 * D_shaft**0.8877])</span>
<span class="sd">        else:</span>
<span class="sd">            out = [D_shaft, .2762 * D_shaft, 876.7 * D_shaft**1.7195]</span>
<span class="sd">            if deriv:</span>
<span class="sd">                out.extend([1., .2762, 876.7 * 1.7195 * D_shaft**0.7195])</span>

<span class="sd">    elif type == &#39;TRB1&#39;:</span>
<span class="sd">        e = .37</span>
<span class="sd">        Y1 = 0</span>
<span class="sd">        X2 = .4</span>
<span class="sd">        Y2 = 1.6</span>
<span class="sd">        p = 10. / 3</span>
<span class="sd">        C_min = C_calc(F_a, F_r, N_array, p, e, Y1, Y2, X2, life_bearing)</span>
<span class="sd">        if C_min &gt; 670 * D_shaft + 1690:</span>
<span class="sd">            out = [D_shaft, .1335, 269.83 * D_shaft**.441]</span>
<span class="sd">            if deriv:</span>
<span class="sd">                out.extend([1., 0., 269.83 * 0.441 * D_shaft**(0.441 - 1.)])</span>
<span class="sd">        else:</span>
<span class="sd">            out = [D_shaft, .0740, 92.863 * D_shaft**.8399]</span>
<span class="sd">            if deriv:</span>
<span class="sd">                out.extend([1., 0., 92.863 * 0.8399 * D_shaft**(0.8399 - 1.)])</span>

<span class="sd">    elif type == &#39;CRB&#39;:</span>
<span class="sd">        if (np.max(F_a) / np.max(F_r) &gt;= .5) or (np.min(F_a) / (np.min(F_r)) &gt;= .5):</span>
<span class="sd">            print(&#39;--------------------------------------------------------&#39;)</span>
<span class="sd">            print(&quot;error: axial loads too large for CRB bearing application&quot;)</span>
<span class="sd">            print(&#39;--------------------------------------------------------&#39;)</span>
<span class="sd">        else:</span>
<span class="sd">            e = 0.2</span>
<span class="sd">            Y1 = 0</span>
<span class="sd">            X2 = 0.92</span>
<span class="sd">            Y2 = 0.6</span>
<span class="sd">            p = 10. / 3</span>
<span class="sd">            C_min = C_calc(F_a, F_r, N_array, p, e, Y1, Y2, X2, life_bearing)</span>
<span class="sd">            if C_min &gt; 4526.5 * D_shaft**.9556:</span>
<span class="sd">                out = [D_shaft, .2603 * D_shaft, 1070.8 * D_shaft**1.8278]</span>
<span class="sd">                if deriv:</span>
<span class="sd">                    out.extend([1., .2603, 1070.8 * 1.8278 * D_shaft**0.8278])</span>
<span class="sd">            else:</span>
<span class="sd">                out = [D_shaft, .1136 * D_shaft, 304.19 * D_shaft**1.8885]</span>
<span class="sd">                if deriv:</span>
<span class="sd">                    out.extend([1., .1136, 304.19 * 1.8885 * D_shaft**0.8885])</span>

<span class="sd">    elif type == &#39;TRB2&#39;:</span>
<span class="sd">        e = 0.4</span>
<span class="sd">        Y1 = 2.5</span>
<span class="sd">        X2 = 0.4</span>
<span class="sd">        Y2 = 1.75</span>
<span class="sd">        p = 10. / 3</span>
<span class="sd">        C_min = C_calc(F_a, F_r, N_array, p, e, Y1, Y2, X2, life_bearing)</span>
<span class="sd">        if C_min &gt; 6579.9 * D_shaft**.8592:</span>
<span class="sd">            out = [D_shaft, .3689 * D_shaft, 1442.6 * D_shaft**1.8932]</span>
<span class="sd">            if deriv:</span>
<span class="sd">                out.extend([1., .3689, 1442.6 * 1.8932 * D_shaft**.8932])</span>
<span class="sd">        else:</span>
<span class="sd">            out = [D_shaft, .1499 * D_shaft, 543.01 * D_shaft**1.9043]</span>
<span class="sd">            if deriv:</span>
<span class="sd">                out.extend([1., .1499, 543.01 * 1.9043 * D_shaft**.9043])</span>

<span class="sd">    elif type == &#39;RB&#39;:  # factors depend on ratio Fa/C0, C0 depends on bearing... TODO: add this functionality</span>
<span class="sd">        e = 0.4</span>
<span class="sd">        Y1 = 1.6</span>
<span class="sd">        X2 = 0.75</span>
<span class="sd">        Y2 = 2.15</span>
<span class="sd">        p = 3.</span>
<span class="sd">        C_min = C_calc(F_a, F_r, N_array, p, e, Y1, Y2, X2, life_bearing)</span>
<span class="sd">        if C_min &gt; 884.5 * D_shaft**.9964:</span>
<span class="sd">            out = [D_shaft, .1571, 646.46 * D_shaft**2.]</span>
<span class="sd">            if deriv:</span>
<span class="sd">                out.extend([1., 0., 646.46 * 2. * D_shaft])</span>
<span class="sd">        else:</span>
<span class="sd">            out = [D_shaft, .0839, 229.47 * D_shaft**1.8036]</span>
<span class="sd">            if deriv:</span>
<span class="sd">                out.extend([1.0, 0.0, 229.47 * 1.8036 * D_shaft**0.8036])</span>

<span class="sd">    return out</span>

<span class="sd">#-------------------------------------------------------------------------</span>
<span class="sd">def get_Damage_Brng2(self):</span>
<span class="sd">    I = (pi / 64.0) * (self.D_med**4 - self.D_in**4)</span>
<span class="sd">    J = I * 2</span>
<span class="sd">    Area = pi / 4. * (self.D_med**2 - self.D_in**2)</span>
<span class="sd">    self.LssWeight = self.density * 9.81 * \</span>
<span class="sd">        (((pi / 12) * (self.D_max**2 + self.D_med**2 + self.D_max *</span>
<span class="sd">                       self.D_med) * (self.L_mb)) - (pi / 4 * self.L_mb * self.D_in**2))</span>

<span class="sd">    self.Fz1stoch = (-self.My_stoch) / (self.L_mb)</span>
<span class="sd">    self.Fy1stoch = self.Mz_stoch / self.L_mb</span>
<span class="sd">    self.My2stoch = 0.  # My_stoch - abs(Fz1stoch)*self.L_mb #=0</span>
<span class="sd">    self.Mz2stoch = 0.  # Mz_stoch - abs(Fy1stoch)*self.L_mb #=0</span>

<span class="sd">    # create stochastic loads across N</span>
<span class="sd">    stoch_bend2 = (self.My2stoch**2 + self.Mz2stoch **</span>
<span class="sd">                   2)**(0.5) * self.D_med / (2. * I)</span>
<span class="sd">    stoch_shear2 = abs(self.Mx_stoch * self.D_med / (2. * J))</span>
<span class="sd">    # all normal force held by downwind bearing</span>
<span class="sd">    stoch_normal2 = self.Fx_stoch / Area * cos(self.shaft_angle)</span>
<span class="sd">    stoch_stress2 = ((stoch_bend2 + stoch_normal2) **</span>
<span class="sd">                     2 + 3. * stoch_shear2**2)**(0.5)</span>

<span class="sd">    # create mean loads</span>
<span class="sd">    # Fz_mean*self.distance_hub2mb*self.D_med/(2.*I) #not mean, but deterministic</span>
<span class="sd">    mean_bend2 = 0.</span>
<span class="sd">    mean_shear2 = self.Mx_mean * self.D_med / (2. * J)</span>
<span class="sd">    mean_normal2 = self.Fx_mean / Area * \</span>
<span class="sd">        cos(self.shaft_angle) + (self.rotorWeight +</span>
<span class="sd">                                 self.LssWeight) * sin(self.shaft_angle)</span>
<span class="sd">    mean_stress2 = ((mean_bend2 + mean_normal2) **</span>
<span class="sd">                    2 + 3. * mean_shear2**2)**(0.5)</span>
<span class="sd">    # apply Goodman with compressive (-) mean stress</span>
<span class="sd">    S_mod_stoch2 = Goodman(stoch_stress2, -mean_stress2, self.S_ut)</span>

<span class="sd">    # Use Palmgren-Miner linear damage rule to add damage from stochastic</span>
<span class="sd">    # load ranges</span>
<span class="sd">    DEL_y = self.Fx_stoch.copy()  # initialize</span>
<span class="sd">    for i in range(self.num_pts):</span>
<span class="sd">        DEL_y[i] = self.N[i] / \</span>
<span class="sd">            (Ninterp(S_mod_stoch2[i], self.SN_a, self.SN_b))</span>

<span class="sd">    # damage from stochastic loading</span>
<span class="sd">    self.Damage = scp.integrate.simps(DEL_y, x=self.N, even=&#39;avg&#39;)</span>

<span class="sd">    # create deterministic loads occurring N_rotor times</span>
<span class="sd">    self.Fz1determ = (self.gearboxWeight * self.L_gb - self.LssWeight * .5 *</span>
<span class="sd">                      self.L_mb - self.rotorWeight * (self.L_mb + self.distance_hub2mb)) / (self.L_mb)</span>
<span class="sd">    # -rotorWeight*(self.distance_hub2mb+self.L_mb) + Fz1determ*self.L_mb - self.LssWeight*.5*self.L_mb + self.gearboxWeight*self.L_gb</span>
<span class="sd">    self.My2determ = self.gearboxWeight * self.L_gb</span>
<span class="sd">    self.determ_stress2 = abs(self.My2determ * self.D_med / (2. * I))</span>

<span class="sd">    S_mod_determ2 = Goodman(self.determ_stress2, -mean_stress2, self.S_ut)</span>

<span class="sd">    if S_mod_determ2 &gt; 0:</span>
<span class="sd">        self.Damage += self.N_rotor / \</span>
<span class="sd">            (Ninterp(S_mod_determ2, self.SN_a, self.SN_b))</span>

<span class="sd">def get_Damage_Brng1(self):</span>
<span class="sd">    self.D_in = self.shaft_ratio * self.D_max</span>
<span class="sd">    self.D_max = (self.D_max**4 + self.D_in**4)**0.25</span>
<span class="sd">    self.D_min = (self.D_min**4 + self.D_in**4)**0.25</span>
<span class="sd">    I = (pi / 64.0) * (self.D_max**4 - self.D_in**4)</span>
<span class="sd">    J = I * 2</span>
<span class="sd">    Area = pi / 4. * (self.D_max**2 - self.D_in**2)</span>
<span class="sd">    self.LssWeight = self.density * 9.81 * \</span>
<span class="sd">        (((pi / 12) * (self.D_max**2 + self.D_min**2 + self.D_max *</span>
<span class="sd">                       self.D_min) * (self.L_ms)) - (pi / 4 * self.L_ms * self.D_in**2))</span>

<span class="sd">    # create stochastic loads across N</span>
<span class="sd">    stoch_bend1 = (self.My_stoch**2 + self.Mz_stoch **</span>
<span class="sd">                   2)**(0.5) * self.D_max / (2. * I)</span>
<span class="sd">    stoch_shear1 = abs(self.Mx_stoch * self.D_max / (2. * J))</span>
<span class="sd">    stoch_normal1 = self.Fx_stoch / Area * cos(self.shaft_angle)</span>
<span class="sd">    stoch_stress1 = ((stoch_bend1 + stoch_normal1) **</span>
<span class="sd">                     2 + 3. * stoch_shear1**2)**(0.5)</span>

<span class="sd">    # create mean loads</span>
<span class="sd">    # Fz_mean*self.distance_hub2mb*self.D_max/(2.*I) #not mean, but deterministic</span>
<span class="sd">    mean_bend1 = 0</span>
<span class="sd">    mean_shear1 = self.Mx_mean * self.D_max / (2. * J)</span>
<span class="sd">    mean_normal1 = self.Fx_mean / Area * \</span>
<span class="sd">        cos(self.shaft_angle) + (self.rotorWeight +</span>
<span class="sd">                                 self.LssWeight) * sin(self.shaft_angle)</span>
<span class="sd">    mean_stress1 = ((mean_bend1 + mean_normal1) **</span>
<span class="sd">                    2 + 3. * mean_shear1**2)**(0.5)</span>

<span class="sd">    # apply Goodman with compressive (-) mean stress</span>
<span class="sd">    S_mod_stoch1 = Goodman(stoch_stress1, -mean_stress1, self.S_ut)</span>

<span class="sd">    # Use Palmgren-Miner linear damage rule to add damage from stochastic</span>
<span class="sd">    # load ranges</span>
<span class="sd">    DEL_y = self.Fx_stoch.copy()  # initialize</span>
<span class="sd">    for i in range(self.num_pts):</span>
<span class="sd">        DEL_y[i] = self.N[i] / \</span>
<span class="sd">            (Ninterp(S_mod_stoch1[i], self.SN_a, self.SN_b))</span>

<span class="sd">    # damage from stochastic loading</span>
<span class="sd">    self.Damage = scp.integrate.simps(DEL_y, x=self.N, even=&#39;avg&#39;)</span>

<span class="sd">    # create deterministic loads occurring N_rotor times</span>
<span class="sd">    # only deterministic stress at mb1 is bending due to weights</span>
<span class="sd">    determ_stress1 = abs(</span>
<span class="sd">        self.rotorWeight * cos(self.shaft_angle) * self.distance_hub2mb * self.D_max / (2. * I))</span>

<span class="sd">    S_mod_determ = Goodman(determ_stress1, -mean_stress1, self.S_ut)</span>

<span class="sd">    self.Damage += self.N_rotor / \</span>
<span class="sd">        (Ninterp(S_mod_determ, self.SN_a, self.SN_b))</span>

<span class="sd">def setup_Fatigue_Loads(self):</span>
<span class="sd">    R = self.rotor_diameter / 2.0</span>
<span class="sd">    rotor_torque = (self.machine_rating * 1000 /</span>
<span class="sd">                    self.drivetrain_efficiency) / (self.rotor_freq * (pi / 30))</span>
<span class="sd">    Tip_speed_ratio = self.rotor_freq / 30. * pi * R / self.Vrated</span>
<span class="sd">    rho_air = 1.225  # kg/m^3 density of air TODO add as input</span>
<span class="sd">    p_o = 4. / 3 * rho_air * ((4 * pi * self.rotor_freq / 60 * R / 3)**2 + self.Vrated**2) * (</span>
<span class="sd">        pi * R / (self.blade_number * Tip_speed_ratio * (Tip_speed_ratio**2 + 1)**(.5)))</span>
<span class="sd">    # characteristic frequency on rotor from turbine of given blade number</span>
<span class="sd">    # [Hz]</span>
<span class="sd">    n_c = self.blade_number * self.rotor_freq / 60</span>
<span class="sd">    # number of rotor rotations based off of weibull curve. .827 comes from</span>
<span class="sd">    # lower rpm than rated at lower wind speeds</span>
<span class="sd">    self.N_f = self.availability * n_c * (self.T_life * 365 * 24 * 60 * 60) * exp(-(</span>
<span class="sd">        self.cut_in / self.weibull_A)**self.weibull_k) - exp(-(self.cut_out / self.weibull_A)**self.weibull_k)</span>

<span class="sd">    k_b = 2.5  # calculating rotor pressure from all three blades. Use kb=1 for individual blades</span>

<span class="sd">    if self.IEC_Class == &#39;A&#39;:  # From IEC 61400-1 TODO consider calculating based off of 10-minute windspeed and weibull parameters, include neighboring wake effects?</span>
<span class="sd">        I_t = 0.18</span>
<span class="sd">    elif self.IEC_Class == &#39;B&#39;:</span>
<span class="sd">        I_t = 0.14</span>
<span class="sd">    else:</span>
<span class="sd">        I_t = 0.12</span>

<span class="sd">    Beta = 0.11 * k_b * (I_t + 0.1) * (self.weibull_A + 4.4)</span>

<span class="sd">    # for analysis with N on log scale, makes larger loads contain finer</span>
<span class="sd">    # step sizes</span>
<span class="sd">    self.num_pts = 100</span>
<span class="sd">    # with zeros: N=np.logspace(log10(1.0),log10(N_f),endpoint=True,num=self.num_pts)</span>
<span class="sd">    self.N = np.logspace((log10(self.N_f) - (2 * k_b - 0.18) / Beta),</span>
<span class="sd">                         log10(self.N_f), endpoint=True, num=self.num_pts)</span>
<span class="sd">    self.N_rotor = self.N_f / 3.</span>
<span class="sd">    F_stoch = self.N.copy()</span>

<span class="sd">    k_r = 0.8  # assuming natural frequency of rotor is significantly larger than rotor rotational frequency</span>

<span class="sd">    for i in range(self.num_pts):</span>
<span class="sd">        F_stoch[i] = self.standardrange(self.N[i], self.N_f, Beta, k_b)</span>

<span class="sd">    Fx_factor = (.3649 * log(self.rotor_diameter) - 1.074)</span>
<span class="sd">    Mx_factor = (.0799 * log(self.rotor_diameter) - .2577)</span>
<span class="sd">    My_factor = (.172 * log(self.rotor_diameter) - .5943)</span>
<span class="sd">    Mz_factor = (.1659 * log(self.rotor_diameter) - .5795)</span>

<span class="sd">    self.Fx_stoch = (F_stoch.copy() * 0.5 * p_o * (R)) * Fx_factor</span>
<span class="sd">    self.Mx_stoch = (F_stoch.copy() * 0.45 * p_o *</span>
<span class="sd">                     (R)**2) * Mx_factor  # *0.31</span>
<span class="sd">    self.My_stoch = (F_stoch.copy() * 0.33 * p_o *</span>
<span class="sd">                     k_r * (R)**2) * My_factor  # *0.25</span>
<span class="sd">    self.Mz_stoch = (F_stoch.copy() * 0.33 * p_o *</span>
<span class="sd">                     k_r * (R)**2) * Mz_factor  # *0.25</span>

<span class="sd">    self.Fx_mean = 0.5 * p_o * R * self.blade_number * Fx_factor</span>
<span class="sd">    self.Mx_mean = 0.5 * rotor_torque * Mx_factor</span>
<span class="sd">    self.rotorWeight = self.rotor_mass * self.g</span>


<span class="sd"># Code remove from LowSpeedShaft4pt component</span>
<span class="sd">############################################</span>
<span class="sd"># inputs into LSS for fatigue calculations:</span>

<span class="sd">check_fatigue = Enum(0,(0,1,2),iotype = &#39;in&#39;, desc = &#39;turns on and off fatigue check&#39;)</span>

<span class="sd">#fatigue1 variables</span>
<span class="sd">rotor_freq = Float(iotype = &#39;in&#39;, units = &#39;rpm&#39;, desc=&#39;rated rotor speed&#39;)</span>
<span class="sd">availability = Float(.95,iotype = &#39;in&#39;, desc = &#39;turbine availability&#39;)</span>
<span class="sd">fatigue_exponent = Float(0,iotype = &#39;in&#39;, desc = &#39;fatigue exponent of material&#39;)</span>
<span class="sd">S_ut = Float(700e6,iotype = &#39;in&#39;, units = &#39;Pa&#39;, desc = &#39;ultimate tensile strength of material&#39;)</span>
<span class="sd">weibull_A = Float(iotype = &#39;in&#39;, units = &#39;m/s&#39;, desc = &#39;weibull scale parameter &quot;A&quot; of 10-minute windspeed probability distribution&#39;)</span>
<span class="sd">weibull_k = Float(iotype = &#39;in&#39;, desc = &#39;weibull shape parameter &quot;k&quot; of 10-minute windspeed probability distribution&#39;)</span>
<span class="sd">blade_number = Float(iotype = &#39;in&#39;, desc = &#39;number of blades on rotor, 2 or 3&#39;)</span>
<span class="sd">cut_in = Float(iotype = &#39;in&#39;, units = &#39;m/s&#39;, desc = &#39;cut-in windspeed&#39;)</span>
<span class="sd">cut_out = Float(iotype = &#39;in&#39;, units = &#39;m/s&#39;, desc = &#39;cut-out windspeed&#39;)</span>
<span class="sd">Vrated = Float(iotype = &#39;in&#39;, units = &#39;m/s&#39;, desc = &#39;rated windspeed&#39;)</span>
<span class="sd">T_life = Float(iotype = &#39;in&#39;, units = &#39;yr&#39;, desc = &#39;cut-in windspeed&#39;)</span>

<span class="sd"># fatigue2 variables</span>
<span class="sd">rotor_thrust_distribution = Array(iotype=&#39;in&#39;, units =&#39;N&#39;, desc = &#39;thrust distribution across turbine life&#39;)</span>
<span class="sd">rotor_thrust_count = Array(iotype=&#39;in&#39;, desc = &#39;corresponding cycle array for thrust distribution&#39;)</span>
<span class="sd">rotor_Fy_distribution = Array(iotype=&#39;in&#39;, units =&#39;N&#39;, desc = &#39;Fy distribution across turbine life&#39;)</span>
<span class="sd">rotor_Fy_count = Array(iotype=&#39;in&#39;, desc = &#39;corresponding cycle array for Fy distribution&#39;)</span>
<span class="sd">rotor_Fz_distribution = Array(iotype=&#39;in&#39;, units =&#39;N&#39;, desc = &#39;Fz distribution across turbine life&#39;)</span>
<span class="sd">rotor_Fz_count = Array(iotype=&#39;in&#39;, desc = &#39;corresponding cycle array for Fz distribution&#39;) </span>
<span class="sd">rotor_torque_distribution = Array(iotype=&#39;in&#39;, units =&#39;N*m&#39;, desc = &#39;torque distribution across turbine life&#39;)</span>
<span class="sd">rotor_torque_count = Array(iotype=&#39;in&#39;, desc = &#39;corresponding cycle array for torque distribution&#39;) </span>
<span class="sd">rotor_My_distribution = Array(iotype=&#39;in&#39;, units =&#39;N*m&#39;, desc = &#39;My distribution across turbine life&#39;)</span>
<span class="sd">rotor_My_count = Array(iotype=&#39;in&#39;, desc = &#39;corresponding cycle array for My distribution&#39;) </span>
<span class="sd">rotor_Mz_distribution = Array(iotype=&#39;in&#39;, units =&#39;N*m&#39;, desc = &#39;Mz distribution across turbine life&#39;)</span>
<span class="sd">rotor_Mz_count = Array(iotype=&#39;in&#39;, desc = &#39;corresponding cycle array for Mz distribution&#39;)</span>

<span class="sd"># LSS fatigue check calculations </span>
<span class="sd"># fatigue check Taylor Parsons 6/14</span>
<span class="sd">if self.check_fatigue == 1 or self.check_fatigue == 2:</span>

<span class="sd">    # checks to make sure all inputs are reasonable</span>
<span class="sd">    if self.rotor_mass &lt; 100:</span>
<span class="sd">        [self.rotor_mass] = get_rotor_mass(self.machine_rating, False)</span>

<span class="sd">    # material properties 34CrNiMo6 steel +QT, large diameter</span>
<span class="sd">    self.n_safety = 2.5</span>
<span class="sd">    if self.S_ut &lt;= 0:</span>
<span class="sd">        self.S_ut = 700.0e6  # Pa</span>

<span class="sd">    # calculate material props for fatigue</span>
<span class="sd">    Sm = 0.9 * self.S_ut  # for bending situations, material strength at 10^3 cycles</span>

<span class="sd">    if self.fatigue_exponent != 0:</span>
<span class="sd">        if self.fatigue_exponent &gt; 0:</span>
<span class="sd">            self.SN_b = - self.fatigue_exponent</span>
<span class="sd">        else:</span>
<span class="sd">            self.SN_b = self.fatigue_exponent</span>
<span class="sd">    else:</span>
<span class="sd">        C_size = 0.6  # diameter larger than 10&quot;</span>
<span class="sd">        # machined surface 272*(self.S_ut/1e6)**-.995 #forged</span>
<span class="sd">        C_surf = 4.51 * (self.S_ut / 1e6)**-.265</span>
<span class="sd">        C_temp = 1  # normal operating temps</span>
<span class="sd">        C_reliab = 0.814  # 99% reliability</span>
<span class="sd">        C_envir = 1.  # enclosed environment</span>
<span class="sd">        Se = C_size * C_surf * C_temp * C_reliab * C_envir * .5 * \</span>
<span class="sd">            self.S_ut  # modified endurance limit for infinite life (should be Sf)\</span>
<span class="sd">        Nfinal = 5e8  # point where fatigue limit occurs under hypothetical S-N curve TODO adjust to fit actual data</span>
<span class="sd">        # assuming no endurance limit (high strength steel)</span>
<span class="sd">        z = log10(1e3) - log10(Nfinal)</span>
<span class="sd">        self.SN_b = 1 / z * log10(Sm / Se)</span>
<span class="sd">    self.SN_a = Sm / (1000.**self.SN_b)</span>


<span class="sd">    if self.check_fatigue == 1:</span>

<span class="sd">        setup_Fatigue_Loads(self)</span>

<span class="sd">        # upwind bearing calculations</span>
<span class="sd">        iterationstep = 0.001</span>
<span class="sd">        diameter_limit = 5.0</span>
<span class="sd">        while True:</span>
<span class="sd">            get_Damage_Brng1(self)</span>
<span class="sd">            if self.Damage &lt; 1 or self.D_max &gt;= diameter_limit:</span>
<span class="sd">                break</span>
<span class="sd">            else:</span>
<span class="sd">                self.D_max += iterationstep</span>

<span class="sd">        # downwind bearing calculations</span>
<span class="sd">        diameter_limit = 5.0</span>
<span class="sd">        iterationstep = 0.001</span>
<span class="sd">        while True:</span>
<span class="sd">            get_Damage_Brng2(self)</span>
<span class="sd">            if self.Damage &lt; 1 or self.D_med &gt;= diameter_limit:</span>
<span class="sd">                break</span>
<span class="sd">            else:</span>
<span class="sd">                self.D_med += iterationstep</span>

<span class="sd">        # begin bearing calculations</span>
<span class="sd">        # counts per rotation (not defined by characteristic frequency</span>
<span class="sd">        # 3n_rotor)</span>
<span class="sd">        N_bearings = self.N / self.blade_number</span>

<span class="sd">        # radial stochastic + deterministic mean</span>
<span class="sd">        Fr1_range = ((abs(self.Fz1stoch) + abs(self.Fz1determ))</span>
<span class="sd">                     ** 2 + self.Fy1stoch**2)**.5</span>
<span class="sd">        Fa1_range = np.zeros(len(self.Fy1stoch))</span>

<span class="sd">        #...calculate downwind forces</span>
<span class="sd">        lss_weight = self.density * 9.81 * \</span>
<span class="sd">            (((pi / 12) * (self.D_max**2 + self.D_med**2 + self.D_max *</span>
<span class="sd">                           self.D_med) * (self.L_mb)) - (pi / 4 * self.L_mb * self.D_in**2))</span>
<span class="sd">        Fy2stoch = -self.Mz_stoch / (self.L_mb)  # = -Fy1 - Fy_stoch</span>
<span class="sd">        Fz2stoch = -(lss_weight * 2. / 3. * self.L_mb - self.My_stoch) / (self.L_mb) + (lss_weight + self.shrinkDiscWeight + self.gearboxWeight) * \</span>
<span class="sd">            cos(self.shaft_angle) - \</span>
<span class="sd">            self.rotorWeight  # -Fz1 +Weights*cos(gamma)-Fz_stoch+Fz_mean (Fz_mean is in negative direction)</span>
<span class="sd">        Fr2_range = (Fy2stoch**2 + (Fz2stoch + abs(-self.rotorWeight * distance_hub2mb +</span>
<span class="sd">                                                   0.5 * lss_weight + self.gearboxWeight * self.L_gb / self.L_mb))**2)**0.5</span>
<span class="sd">        Fa2_range = self.Fx_stoch * cos(self.shaft_angle) + (</span>
<span class="sd">            self.rotorWeight + lss_weight) * sin(self.shaft_angle)  # axial stochastic + mean</span>

<span class="sd">        life_bearing = self.N_f / self.blade_number</span>

<span class="sd">        [self.D_max_a, facewidth_max, bearing1mass] = fatigue_for_bearings(</span>
<span class="sd">            self.D_max, Fr1_range, Fa1_range, N_bearings, life_bearing, self.mb1Type, False)</span>
<span class="sd">        [self.D_med_a, facewidth_med, bearing2mass] = fatigue_for_bearings(</span>
<span class="sd">            self.D_med, Fr2_range, Fa2_range, N_bearings, life_bearing, self.mb2Type, False)</span>

<span class="sd">    # elif self.check_fatigue == 2: # untested and not used currently</span>
<span class="sd">    #   Fx = self.rotor_thrust_distribution</span>
<span class="sd">    #   n_Fx = self.rotor_thrust_count</span>
<span class="sd">    #   Fy = self.rotor_Fy_distribution</span>
<span class="sd">    #   n_Fy = self.rotor_Fy_count</span>
<span class="sd">    #   Fz = self.rotor_Fz_distribution</span>
<span class="sd">    #   n_Fz = self.rotor_Fz_count</span>
<span class="sd">    #   Mx = self.rotor_torque_distribution</span>
<span class="sd">    #   n_Mx = self.rotor_torque_count</span>
<span class="sd">    #   My = self.rotor_My_distribution</span>
<span class="sd">    #   n_My = self.rotor_My_count</span>
<span class="sd">    #   Mz = self.rotor_Mz_distribution</span>
<span class="sd">    #   n_Mz = self.rotor_Mz_count</span>

<span class="sd">    #   def Ninterp(L_ult,L_range,m):</span>
<span class="sd">    # return (L_ult/(.5*L_range))**m #TODO double-check that the input</span>
<span class="sd">    # will be the load RANGE instead of load amplitudes. May also</span>
<span class="sd">    # include means</span>

<span class="sd">    #   #upwind bearing calcs</span>
<span class="sd">    #   diameter_limit = 5.0</span>
<span class="sd">    #   iterationstep=0.001</span>
<span class="sd">    #   #upwind bearing calcs</span>
<span class="sd">    #   while True:</span>
<span class="sd">    #       self.Damage = 0</span>
<span class="sd">    #       Fx_ult = self.SN_a*(pi/4.*(self.D_max**2-self.D_in**2))</span>
<span class="sd">    #       Fyz_ult = self.SN_a*(pi*(self.D_max**4-self.D_in**4))/(self.D_max*64.)/self.distance_hub2mb</span>
<span class="sd">    #       Mx_ult = self.SN_a*(pi*(self.D_max**4-self.D_in**4))/(32*(3)**.5*self.D_max)</span>
<span class="sd">    #       Myz_ult = self.SN_a*(pi*(self.D_max**4-self.D_in**4))/(self.D_max*64.)</span>
<span class="sd">    #       if Fx_ult !=0 and np.all(n_Fx) != 0:</span>
<span class="sd">    #           self.Damage+=scp.integrate.simps(n_Fx/Ninterp(Fx_ult,Fx,-1/self.SN_b),x=n_Fx,even = &#39;avg&#39;)</span>
<span class="sd">    #       if Fyz_ult !=0:</span>
<span class="sd">    #           if np.all(n_Fy) != 0:</span>
<span class="sd">    #               self.Damage+=scp.integrate.simps(abs(n_Fy/Ninterp(Fyz_ult,Fy,-1/self.SN_b)),x=n_Fy,even = &#39;avg&#39;)</span>
<span class="sd">    #           if np.all(n_Fz) != 0:</span>
<span class="sd">    #               self.Damage+=scp.integrate.simps(abs(n_Fz/Ninterp(Fyz_ult,Fz,-1/self.SN_b)),x=n_Fz,even = &#39;avg&#39;)</span>
<span class="sd">    #       if Mx_ult !=0 and np.all(n_Mx) != 0:</span>
<span class="sd">    #           self.Damage+=scp.integrate.simps(abs(n_Mx/Ninterp(Mx_ult,Mx,-1/self.SN_b)),x=n_Mx,even = &#39;avg&#39;)</span>
<span class="sd">    #       if Myz_ult!=0:</span>
<span class="sd">    #           if np.all(n_My) != 0:</span>
<span class="sd">    #               self.Damage+=scp.integrate.simps(abs(n_My/Ninterp(Myz_ult,My,-1/self.SN_b)),x=n_My,even = &#39;avg&#39;)</span>
<span class="sd">    #           if np.all(n_Mz) != 0:</span>
<span class="sd">    #               self.Damage+=scp.integrate.simps(abs(n_Mz/Ninterp(Myz_ult,Mz,-1/self.SN_b)),x=n_Mz,even = &#39;avg&#39;)</span>

<span class="sd">    #       if self.Damage &lt;= 1 or self.D_max &gt;= diameter_limit:</span>
<span class="sd">    #           break</span>
<span class="sd">    #       else:</span>
<span class="sd">    #           self.D_max+=iterationstep</span>
<span class="sd">    #   #downwind bearing calcs</span>
<span class="sd">    #   while True:</span>
<span class="sd">    #       self.Damage = 0</span>
<span class="sd">    #       Fx_ult = self.SN_a*(pi/4.*(self.D_med**2-self.D_in**2))</span>
<span class="sd">    #       Mx_ult = self.SN_a*(pi*(self.D_med**4-self.D_in**4))/(32*(3)**.5*self.D_med)</span>
<span class="sd">    #       if Fx_ult !=0:</span>
<span class="sd">    #           self.Damage+=scp.integrate.simps(n_Fx/Ninterp(Fx_ult,Fx,-1/self.SN_b),x=n_Fx,even = &#39;avg&#39;)</span>
<span class="sd">    #       if Mx_ult !=0:</span>
<span class="sd">    #           self.Damage+=scp.integrate.simps(n_Mx/Ninterp(Mx_ult,Mx,-1/self.SN_b),x=n_Mx,even = &#39;avg&#39;)</span>

<span class="sd">    #       if self.Damage &lt;= 1 or self.D_med&gt;= diameter_limit:</span>
<span class="sd">    #           break</span>
<span class="sd">    #       else:</span>
<span class="sd">    #           self.D_med+=iterationstep</span>

<span class="sd">    #   #bearing calcs</span>
<span class="sd">    #   if self.availability != 0 and rotor_freq != 0 and self.T_life != 0 and self.cut_out != 0 and self.weibull_A != 0:</span>
<span class="sd">    #       N_rotations = self.availability*rotor_freq/60.*(self.T_life*365*24*60*60)*exp(-(self.cut_in/self.weibull_A)**self.weibull_k)-exp(-(self.cut_out/self.weibull_A)**self.weibull_k)</span>
<span class="sd">    #   elif np.max(n_Fx &gt; 1e6):</span>
<span class="sd">    #       N_rotations = np.max(n_Fx)/self.blade_number</span>
<span class="sd">    #   elif np.max(n_My &gt; 1e6):</span>
<span class="sd">    #       N_rotations = np.max(n_My)/self.blade_number</span>
<span class="sd">    #   Fz1_Fz = Fz*(self.L_mb+self.distance_hub2mb)/self.L_mb</span>
<span class="sd">    #   Fz1_My = My/self.L_mb</span>
<span class="sd">    #   Fy1_Fy = -Fy*(self.L_mb+self.distance_hub2mb)/self.L_mb</span>
<span class="sd">    #   Fy1_Mz = Mz/self.L_mb</span>
<span class="sd">    #   [self.D_max_a,facewidth_max,bearing1mass] = fatigue2_for_bearings(self.D_max,self.mb1Type,np.zeros(2),np.array([1,2]),Fy1_Fy,n_Fy/self.blade_number,Fz1_Fz,n_Fz/self.blade_number,Fz1_My,n_My/self.blade_number,Fy1_Mz,n_Mz/self.blade_number,N_rotations)</span>
<span class="sd">    #   Fz2_Fz = Fz*self.distance_hub2mb/self.L_mb</span>
<span class="sd">    #   Fz2_My = My/self.L_mb</span>
<span class="sd">    #   Fy2_Fy = Fy*self.distance_hub2mb/self.L_mb</span>
<span class="sd">    #   Fy2_Mz = Mz/self.L_mb</span>
<span class="sd">    #   [self.D_med_a,facewidth_med,bearing2mass] = fatigue2_for_bearings(self.D_med,self.mb2Type,Fx,n_Fx/self.blade_number,Fy2_Fy,n_Fy/self.blade_number,Fz2_Fz,n_Fz/self.blade_number,Fz2_My,n_My/self.blade_number,Fy2_Mz,n_Mz/self.blade_number,N_rotations)</span>


<span class="sd"># Code remove from LowSpeedShaft3pt component</span>
<span class="sd">############################################</span>
<span class="sd"># inputs into LSS for fatigue calculations:</span>

<span class="sd">check_fatigue = Enum(0,(0,1,2),iotype = &#39;in&#39;, desc = &#39;turns on and off fatigue check&#39;)</span>

<span class="sd">#fatigue1 variables</span>
<span class="sd">rotor_freq = Float(iotype = &#39;in&#39;, units = &#39;rpm&#39;, desc=&#39;rated rotor speed&#39;)</span>
<span class="sd">availability = Float(.95,iotype = &#39;in&#39;, desc = &#39;turbine availability&#39;)</span>
<span class="sd">fatigue_exponent = Float(0,iotype = &#39;in&#39;, desc = &#39;fatigue exponent of material&#39;)</span>
<span class="sd">S_ut = Float(700e6,iotype = &#39;in&#39;, units = &#39;Pa&#39;, desc = &#39;ultimate tensile strength of material&#39;)</span>
<span class="sd">weibull_A = Float(iotype = &#39;in&#39;, units = &#39;m/s&#39;, desc = &#39;weibull scale parameter &quot;A&quot; of 10-minute windspeed probability distribution&#39;)</span>
<span class="sd">weibull_k = Float(iotype = &#39;in&#39;, desc = &#39;weibull shape parameter &quot;k&quot; of 10-minute windspeed probability distribution&#39;)</span>
<span class="sd">blade_number = Float(iotype = &#39;in&#39;, desc = &#39;number of blades on rotor, 2 or 3&#39;)</span>
<span class="sd">cut_in = Float(iotype = &#39;in&#39;, units = &#39;m/s&#39;, desc = &#39;cut-in windspeed&#39;)</span>
<span class="sd">cut_out = Float(iotype = &#39;in&#39;, units = &#39;m/s&#39;, desc = &#39;cut-out windspeed&#39;)</span>
<span class="sd">Vrated = Float(iotype = &#39;in&#39;, units = &#39;m/s&#39;, desc = &#39;rated windspeed&#39;)</span>
<span class="sd">T_life = Float(iotype = &#39;in&#39;, units = &#39;yr&#39;, desc = &#39;cut-in windspeed&#39;)</span>

<span class="sd"># fatigue2 variables</span>
<span class="sd">rotor_thrust_distribution = Array(iotype=&#39;in&#39;, units =&#39;N&#39;, desc = &#39;thrust distribution across turbine life&#39;)</span>
<span class="sd">rotor_thrust_count = Array(iotype=&#39;in&#39;, desc = &#39;corresponding cycle array for thrust distribution&#39;)</span>
<span class="sd">rotor_Fy_distribution = Array(iotype=&#39;in&#39;, units =&#39;N&#39;, desc = &#39;Fy distribution across turbine life&#39;)</span>
<span class="sd">rotor_Fy_count = Array(iotype=&#39;in&#39;, desc = &#39;corresponding cycle array for Fy distribution&#39;)</span>
<span class="sd">rotor_Fz_distribution = Array(iotype=&#39;in&#39;, units =&#39;N&#39;, desc = &#39;Fz distribution across turbine life&#39;)</span>
<span class="sd">rotor_Fz_count = Array(iotype=&#39;in&#39;, desc = &#39;corresponding cycle array for Fz distribution&#39;) </span>
<span class="sd">rotor_torque_distribution = Array(iotype=&#39;in&#39;, units =&#39;N*m&#39;, desc = &#39;torque distribution across turbine life&#39;)</span>
<span class="sd">rotor_torque_count = Array(iotype=&#39;in&#39;, desc = &#39;corresponding cycle array for torque distribution&#39;) </span>
<span class="sd">rotor_My_distribution = Array(iotype=&#39;in&#39;, units =&#39;N*m&#39;, desc = &#39;My distribution across turbine life&#39;)</span>
<span class="sd">rotor_My_count = Array(iotype=&#39;in&#39;, desc = &#39;corresponding cycle array for My distribution&#39;) </span>
<span class="sd">rotor_Mz_distribution = Array(iotype=&#39;in&#39;, units =&#39;N*m&#39;, desc = &#39;Mz distribution across turbine life&#39;)</span>
<span class="sd">rotor_Mz_count = Array(iotype=&#39;in&#39;, desc = &#39;corresponding cycle array for Mz distribution&#39;)</span>

<span class="sd"># fatigue check Taylor Parsons 6/2014</span>
<span class="sd">if self.check_fatigue == 1 or 2:</span>
<span class="sd">	  #start_time = time.time()</span>
<span class="sd">	  #material properties 34CrNiMo6 steel +QT, large diameter</span>
<span class="sd">	  self.E=2.1e11</span>
<span class="sd">	  self.density=7800.0</span>
<span class="sd">	  self.n_safety = 2.5</span>
<span class="sd">	  if self.S_ut &lt;= 0:</span>
<span class="sd">	    self.S_ut=700.0e6 #Pa</span>
<span class="sd">	  Sm=0.9*self.S_ut #for bending situations, material strength at 10^3 cycles</span>
<span class="sd">	  C_size=0.6 #diameter larger than 10&quot;</span>
<span class="sd">	  C_surf=4.51*(self.S_ut/1e6)**-.265 #machined surface 272*(self.S_ut/1e6)**-.995 #forged</span>
<span class="sd">	  C_temp=1 #normal operating temps</span>
<span class="sd">	  C_reliab=0.814 #99% reliability</span>
<span class="sd">	  C_envir=1. #enclosed environment</span>
<span class="sd">	  Se=C_size*C_surf*C_temp*C_reliab*C_envir*.5*self.S_ut #modified endurance limit for infinite life</span>
<span class="sd">	</span>
<span class="sd">	  if self.fatigue_exponent!=0:</span>
<span class="sd">	    if self.fatigue_exponent &gt; 0:</span>
<span class="sd">	        self.SN_b = - self.fatigue_exponent</span>
<span class="sd">	    else:</span>
<span class="sd">	        self.SN_b = self.fatigue_exponent</span>
<span class="sd">	  else:</span>
<span class="sd">	    Nfinal = 5e8 #point where fatigue limit occurs under hypothetical S-N curve TODO adjust to fit actual data</span>
<span class="sd">	    z=log10(1e3)-log10(Nfinal)  #assuming no endurance limit (high strength steel)</span>
<span class="sd">	    self.SN_b=1/z*log10(Sm/Se)</span>
<span class="sd">	  self.SN_a=Sm/(1000.**self.SN_b)</span>
<span class="sd">	  # print &#39;m:&#39;, -1/self.SN_b</span>
<span class="sd">	  # print &#39;a:&#39;, self.SN_a</span>
<span class="sd">	</span>
<span class="sd">	  if self.check_fatigue == 1:</span>
<span class="sd">	      #checks to make sure all inputs are reasonable</span>
<span class="sd">	      if self.rotor_mass &lt; 100:</span>
<span class="sd">	          [self.rotor_mass] = get_rotor_mass(self.machine_rating,False)</span>
<span class="sd">	</span>
<span class="sd">	      #Rotor Loads calculations using DS472</span>
<span class="sd">	      setup_Fatigue_Loads(self)</span>
<span class="sd">	</span>
<span class="sd">	      #upwind diameter calculations</span>
<span class="sd">	      iterationstep=0.001</span>
<span class="sd">	      diameter_limit = 1.5</span>
<span class="sd">	      while True:</span>
<span class="sd">	</span>
<span class="sd">	          get_Damage_Brng1(self)</span>
<span class="sd">	</span>
<span class="sd">	          if self.Damage &lt; 1 or self.D_max &gt;= diameter_limit:</span>
<span class="sd">	              break</span>
<span class="sd">	          else:</span>
<span class="sd">	              self.D_max+=iterationstep</span>
<span class="sd">	</span>
<span class="sd">	      #begin bearing calculations</span>
<span class="sd">	      N_bearings = self.N/self.blade_number #rotation number</span>
<span class="sd">	</span>
<span class="sd">	      Fz1stoch = (-self.My_stoch)/(self.L_ms)</span>
<span class="sd">	      Fy1stoch = self.Mz_stoch/self.L_ms</span>
<span class="sd">	      Fz1determ = (self.weightGbx*self.L_gb - self.LssWeight*.5*self.L_ms - self.rotorWeight*(self.L_ms+distance_hub2mb)) / (self.L_ms)</span>
<span class="sd">	</span>
<span class="sd">	      Fr_range = ((abs(Fz1stoch)+abs(Fz1determ))**2 +Fy1stoch**2)**.5 #radial stochastic + deterministic mean</span>
<span class="sd">	      Fa_range = self.Fx_stoch*cos(self.shaft_angle) + (self.rotorWeight+self.LssWeight)*sin(self.shaft_angle) #axial stochastic + mean</span>
<span class="sd">	</span>
<span class="sd">	      life_bearing = self.N_f/self.blade_number</span>
<span class="sd">	</span>
<span class="sd">	      [self.D_max_a,facewidth_max,bearingmass] = fatigue_for_bearings(self.D_max, Fr_range, Fa_range, N_bearings, life_bearing, self.mb1Type,False)</span>
<span class="sd">	</span>
<span class="sd">	  # elif self.check_fatigue == 2:</span>
<span class="sd">	  #   Fx = self.rotor_thrust_distribution</span>
<span class="sd">	  #   n_Fx = self.rotor_thrust_count</span>
<span class="sd">	  #   Fy = self.rotor_Fy_distribution</span>
<span class="sd">	  #   n_Fy = self.rotor_Fy_count</span>
<span class="sd">	  #   Fz = self.rotor_Fz_distribution</span>
<span class="sd">	  #   n_Fz = self.rotor_Fz_count</span>
<span class="sd">	  #   Mx = self.rotor_torque_distribution</span>
<span class="sd">	  #   n_Mx = self.rotor_torque_count</span>
<span class="sd">	  #   My = self.rotor_My_distribution</span>
<span class="sd">	  #   n_My = self.rotor_My_count</span>
<span class="sd">	  #   Mz = self.rotor_Mz_distribution</span>
<span class="sd">	  #   n_Mz = self.rotor_Mz_count</span>
<span class="sd">	</span>
<span class="sd">	  #   # print n_Fx</span>
<span class="sd">	  #   # print Fx*.5</span>
<span class="sd">	  #   # print Mx*.5</span>
<span class="sd">	  #   # print -1/self.SN_b</span>
<span class="sd">	</span>
<span class="sd">	  #   def Ninterp(L_ult,L_range,m):</span>
<span class="sd">	  #       return (L_ult/(.5*L_range))**m #TODO double-check that the input will be the load RANGE instead of load amplitudes. Also, may include means?</span>
<span class="sd">	</span>
<span class="sd">	  #   #upwind bearing calcs</span>
<span class="sd">	  #   diameter_limit = 5.0</span>
<span class="sd">	  #   iterationstep=0.001</span>
<span class="sd">	  #   #upwind bearing calcs</span>
<span class="sd">	  #   while True:</span>
<span class="sd">	  #       self.Damage = 0</span>
<span class="sd">	  #       Fx_ult = self.SN_a*(pi/4.*(self.D_max**2-self.D_in**2))</span>
<span class="sd">	  #       Fyz_ult = self.SN_a*(pi*(self.D_max**4-self.D_in**4))/(self.D_max*32*self.distance_hub2mb)</span>
<span class="sd">	  #       Mx_ult = self.SN_a*(pi*(self.D_max**4-self.D_in**4))/(32*(3.**.5)*self.D_max)</span>
<span class="sd">	  #       Myz_ult = self.SN_a*(pi*(self.D_max**4-self.D_in**4))/(self.D_max*64.)</span>
<span class="sd">	  #       if Fx_ult and np.all(n_Fx):</span>
<span class="sd">	  #           self.Damage+=scp.integrate.simps(n_Fx/Ninterp(Fx_ult,Fx,-1/self.SN_b),x=n_Fx,even = &#39;avg&#39;)</span>
<span class="sd">	  #       if Fyz_ult:</span>
<span class="sd">	  #           if np.all(n_Fy):</span>
<span class="sd">	  #               self.Damage+=scp.integrate.simps(abs(n_Fy/Ninterp(Fyz_ult,Fy,-1/self.SN_b)),x=n_Fy,even = &#39;avg&#39;)</span>
<span class="sd">	  #           if np.all(n_Fz):</span>
<span class="sd">	  #               self.Damage+=scp.integrate.simps(abs(n_Fz/Ninterp(Fyz_ult,Fz,-1/self.SN_b)),x=n_Fz,even = &#39;avg&#39;)</span>
<span class="sd">	  #       if Mx_ult and np.all(n_Mx):</span>
<span class="sd">	  #           self.Damage+=scp.integrate.simps(abs(n_Mx/Ninterp(Mx_ult,Mx,-1/self.SN_b)),x=n_Mx,even = &#39;avg&#39;)</span>
<span class="sd">	  #       if Myz_ult:</span>
<span class="sd">	  #           if np.all(n_My):</span>
<span class="sd">	  #               self.Damage+=scp.integrate.simps(abs(n_My/Ninterp(Myz_ult,My,-1/self.SN_b)),x=n_My,even = &#39;avg&#39;)</span>
<span class="sd">	  #           if np.all(n_Mz):</span>
<span class="sd">	  #               self.Damage+=scp.integrate.simps(abs(n_Mz/Ninterp(Myz_ult,Mz,-1/self.SN_b)),x=n_Mz,even = &#39;avg&#39;)</span>
<span class="sd">	</span>
<span class="sd">	  #       print &#39;Upwind Bearing Diameter:&#39;, self.D_max</span>
<span class="sd">	  #       print &#39;self.Damage:&#39;, self.Damage</span>
<span class="sd">	</span>
<span class="sd">	  #       if self.Damage &lt;= 1 or self.D_max &gt;= diameter_limit:</span>
<span class="sd">	  #           # print &#39;Upwind Bearing Diameter:&#39;, self.D_max</span>
<span class="sd">	  #           # print &#39;self.Damage:&#39;, self.Damage</span>
<span class="sd">	  #           #print (time.time() - start_time), &#39;seconds of total simulation time&#39;</span>
<span class="sd">	  #           break</span>
<span class="sd">	  #       else:</span>
<span class="sd">	  #           self.D_max+=iterationstep</span>
<span class="sd">	</span>
<span class="sd">	  #   #bearing calcs</span>
<span class="sd">	  #   if self.availability != 0 and rotor_freq != 0 and self.T_life != 0 and self.cut_out != 0 and self.weibull_A != 0:</span>
<span class="sd">	  #       N_rotations = self.availability*rotor_freq/60.*(self.T_life*365*24*60*60)*exp(-(self.cut_in/self.weibull_A)**self.weibull_k)-exp(-(self.cut_out/self.weibull_A)**self.weibull_k)</span>
<span class="sd">	  #   elif np.max(n_Fx &gt; 1e6):</span>
<span class="sd">	  #       N_rotations = np.max(n_Fx)/self.blade_number</span>
<span class="sd">	  #   elif np.max(n_My &gt; 1e6):</span>
<span class="sd">	  #       N_rotations = np.max(n_My)/self.blade_number</span>
<span class="sd">	</span>
<span class="sd">	  #   # Fz1 = (Fz*(self.L_ms+self.distance_hub2mb)+My)/self.L_ms</span>
<span class="sd">	  #   Fz1_Fz = Fz*(self.L_ms+self.distance_hub2mb)/self.L_ms #force in z direction due to Fz</span>
<span class="sd">	  #   Fz1_My = My/self.L_ms #force in z direction due to My</span>
<span class="sd">	  #   Fy1_Fy = -Fy*(self.L_ms+self.distance_hub2mb)/self.L_ms</span>
<span class="sd">	  #   Fy1_Mz = Mz/self.L_ms</span>
<span class="sd">	  #   [self.D_max_a,facewidth_max,bearingmass] = fatigue2_for_bearings(self.D_max,self.mb1Type,np.zeros(2),np.array([1,2]),Fy1_Fy,n_Fy/self.blade_number,Fz1_Fz,n_Fz/self.blade_number,Fz1_My,n_My/self.blade_number,Fy1_Mz,n_Mz/self.blade_number,N_rotations)</span>
<span class="sd"> </span>
<span class="sd">&#39;&#39;&#39;</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="nav-item nav-item-0"><a href="../../index.html">DriveSE 0.1.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2014, NREL.
      Last updated on Apr 08, 2019.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.6.
    </div>
  </body>
</html>