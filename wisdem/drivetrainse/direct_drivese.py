
import numpy as np
import openmdao.api as om


#--------------------------------------------
class ForceMomentDemux(om.ExplicitComponent):
    def setup(self):
        self.add_input('Fxyz', val=np.zeros(3), units='N', desc='Force components applied at the hub center')
        self.add_input('Mxyz', val=np.zeros(3), units='N*m', desc='Moment components generated by the rotor')

        self.add_output('rotor_bending_moment_x', val=0.0, units='N*m', desc='The bending moment about the x axis')
        self.add_output('rotor_bending_moment_y', val=0.0, units='N*m', desc='The bending moment about the y axis')
        self.add_output('rotor_bending_moment_z', val=0.0, units='N*m', desc='The bending moment about the z axis')
        self.add_output('rotor_thrust',           val=0.0, units='N',   desc='The force along the x axis applied at hub center')
        self.add_output('rotor_force_y',          val=0.0, units='N',   desc='The force along the y axis applied at hub center')
        self.add_output('rotor_force_z',          val=0.0, units='N',   desc='The force along the z axis applied at hub center')

    def compute(self, inputs, outputs):
        outputs['rotor_thrust'], outputs['rotor_force_y'], outputs['rotor_force_z'] = inputs['Fxyz'][0], inputs['Fxyz'][1], inputs['Fxyz'][2]
        outputs['rotor_bending_moment_x'], outputs['rotor_bending_moment_y'], outputs['rotor_bending_moment_z'] = inputs['Mxyz'][0], inputs['Mxyz'][1], inputs['Mxyz'][2]

        

#----------------------------------------------------------------------------------------------

class Generator_OM(om.ExplicitComponent):
    '''Generator class
          The Generator class is used to represent the generator of a wind turbine drivetrain.
          It contains the general properties for a wind turbine component as well as additional design load and dimensional attributes as listed below.
          It contains an update method to determine the mass, mass properties, and dimensions of the component.
    '''

        
    def setup(self):
        # variables
        self.add_input('rotor_diameter', val=0.0, units='m', desc='rotor diameter')
        self.add_input('machine_rating', val=0.0, units='kW', desc='machine rating of generator')
        self.add_input('gear_ratio', val=0.0, desc='overall gearbox ratio')
        self.add_input('hss_length', val=0.0, units='m', desc='length of high speed shaft and brake')
        self.add_input('hss_cm', val=np.array([0.0,0.0,0.0]), units='m', desc='cm of high speed shaft and brake')
        self.add_input('rotor_rpm', val=0.0, units='rpm', desc='Speed of rotor at rated power')
        
        self.add_discrete_input('drivetrain_design', val='geared', desc='geared or single_stage or multi_drive or pm_direct_drive')

        #returns
        self.add_output('generator_mass', val=0.0, units='kg', desc='overall component mass')
        self.add_output('generator_cm', val=np.zeros(3), units='m', desc='center of mass of the component in [x,y,z] for an arbitrary coordinate system')
        self.add_output('generator_I', val=np.zeros(3), units='kg*m**2', desc=' moments of Inertia for the component [Ixx, Iyy, Izz] around its center of mass')

    def compute(self, inputs, outputs, discrete_inputs, discrete_outputs):

        mygen = dc.Generator(discrete_inputs['drivetrain_design'])
        
        (outputs['generator_mass'], outputs['generator_cm'], outputs['generator_I']) \
            = mygen.compute(inputs['rotor_diameter'], inputs['machine_rating'], inputs['gear_ratio'], inputs['hss_length'], inputs['hss_cm'], inputs['rotor_rpm'])

        

        
class DriveSE(om.Group):
    ''' Class Drive4pt defines an OpenMDAO group that represents a wind turbine drivetrain with a 4-point suspension
      (two main bearings). This Group can serve as the root of an OpenMDAO Problem.
    '''

    def initialize(self):
        self.options.declare('number_of_main_bearings')
        self.options.declare('topLevelFlag', default=True)
        self.options.declare('debug', default=False)
        
    def setup(self):
        debug=self.options['debug']
        if not self.options['number_of_main_bearings'] in [1,2]:
            raise ValueError('Number of main bearings must be one or two')
        elif self.options['number_of_main_bearings'] == 2:
            drive4pt = True
        else:
            drive4pt = False

        # Independent variables that are unique to DriveSE
        ivc = om.IndepVarComp()
        # ivc.add_output('gear_ratio', 0.0)
        # ivc.add_output('shaft_angle', 0.0, units='rad')
        # ivc.add_output('shaft_ratio', 0.0)
        # ivc.add_output('shrink_disc_mass', 0.0, units='kg')
        # ivc.add_output('carrier_mass', 0.0, units='kg')
        # ivc.add_output('flange_length', 0.0, units='m')
        # ivc.add_output('overhang', 0.0, units='m')
        # ivc.add_output('distance_hub2mb', 0.0, units='m')
        # ivc.add_output('gearbox_input_xcm', 0.0, units='m')
        # ivc.add_output('hss_input_length', 0.0, units='m')
        # ivc.add_discrete_output('planet_numbers', np.array([0, 0, 0]))
        # ivc.add_discrete_output('drivetrain_design', 'geared')
        # ivc.add_discrete_output('gear_configuration', 'eep')
        if drive4pt:
            ivc.add_discrete_output('mb1Type', 'CARB')
            ivc.add_discrete_output('mb2Type', 'SRB')
        else:
            ivc.add_discrete_output('mb1Type', 'SRB')
        ivc.add_discrete_output('IEC_Class', 'B')
        ivc.add_discrete_output('shaft_factor', 'normal')
        ivc.add_discrete_output('uptower_transformer', True)
        ivc.add_discrete_output('crane', True)
        ivc.add_discrete_output('rna_weightM', True)
        ivc.add_discrete_output('downwind', True)
        # ivc.add_discrete_output('yaw_motors_number', 0)
        self.add_subsystem('ivc', ivc, promotes=['*'])

        # Independent variables that may be duplicated at higher levels of aggregation
        if self.options['topLevelFlag']:
            sivc = IndepVarComp()
            sivc.add_discrete_output('number_of_blades', 0)
            sivc.add_output('tower_top_diameter',     0.0, units='m')
            sivc.add_output('rotor_diameter',         0.0, units='m')
            sivc.add_output('rotor_rpm',              0.0, units='rpm')
            sivc.add_output('rotor_torque',           0.0, units='N*m')
            sivc.add_output('Fxyz',                   np.zeros(3), units='N')
            sivc.add_output('Mxyz',                   np.zeros(3), units='N*m')
            sivc.add_output('blade_mass',             0.0, units='kg')
            sivc.add_output('blade_root_diameter',    0.0, units='m')
            sivc.add_output('blade_length',           0.0, units='m')
            sivc.add_output('blades_I',               np.zeros(6), units='kg*m**2')
            sivc.add_output('gearbox_efficiency',     0.0)
            sivc.add_output('generator_efficiency',   0.0)
            sivc.add_output('tile',                   0.0, units='deg')
            sivc.add_output('machine_rating',         0.0, units='kW')
            self.add_subsystem('sivc', sivc, promotes=['*'])

        # select components
        self.add_subsystem('demux', ForceMomentDemux(), promotes=['*'])
        self.add_subsystem('hub', HubSE(mass_only=True, topLevelFlag=False, debug=debug), promotes=['*'])
        self.add_subsystem('layout', Layout(), promotes=['*'])
        self.add_subsystem('generator', Generator(), promotes=['*'])
        self.add_subsystem('lss', Hub_Rotor_Shaft_Frame(), promotes=['*'])
        self.add_subsystem('mainBearing', MainBearing_OM(bearing_position='main'), promotes=['lss_design_torque','rotor_diameter'])
        self.add_subsystem('secondBearing', MainBearing_OM(bearing_position='second'), promotes=['lss_design_torque','rotor_diameter'])
        self.add_subsystem('hubCM', Hub_CM_Adder_OM(), promotes=['*'])
        self.add_subsystem('highSpeedSide', HighSpeedSide_OM(), promotes=['*']) # TODO- Include in generatorSE
        self.add_subsystem('electronics', Transformer_OM(), promotes=['*'])
        self.add_subsystem('nose', Nose_Stator_Bedplate_Frame(), promotes=['*'])
        self.add_subsystem('above_yaw_massAdder', AboveYawMassAdder_OM(), promotes=['*'])
        self.add_subsystem('yawSystem', YawSystem_OM(), promotes=['*'])
        self.add_subsystem('nacelleSystem', NacelleSystemAdder_OM(), promotes=['*'])
        self.add_subsystem('rna', RNAMass(), promotes=['*'])
        self.add_subsystem('loads', RotorLoads(), promotes=['*'])

        # Connect components where explicit connections needed (for main bearings)
        self.connect('lss_mb1_mass',        ['mainBearing.bearing_mass'])
        self.connect('lss_diameter1',       ['mainBearing.lss_diameter', 'lss_diameter'])
        self.connect('lss_mb1_cm',          ['mainBearing.lss_mb_cm'])
        self.connect('mainBearing.mb_mass', ['mb1_mass'])
        self.connect('mainBearing.mb_cm',   ['mb1_cm', 'MB1_location'])
        self.connect('mainBearing.mb_I',    ['mb1_I'])

        if drive4pt:
            self.connect('lss_mb2_mass',          ['secondBearing.bearing_mass'])
            self.connect('lss_diameter2',         ['secondBearing.lss_diameter'])
            self.connect('lss_mb2_cm',            ['secondBearing.lss_mb_cm'])
            self.connect('secondBearing.mb_mass', ['mb2_mass'])
            self.connect('secondBearing.mb_cm',   ['mb2_cm'])
            self.connect('secondBearing.mb_I',    ['mb2_I'])

        self.connect('lss_cm',       'lss_location',       src_indices=[0])
        self.connect('hss_cm',       'hss_location',       src_indices=[0])
        self.connect('gearbox_cm',   'gearbox_location',   src_indices=[0])
        self.connect('generator_cm', 'generator_location', src_indices=[0])
            

#------------------------------------------------------------------
# examples

def nacelle_example_5MW_baseline_3pt(debug=False):

    # NREL 5 MW Drivetrain variables
    # geared 3-stage Gearbox with induction generator machine

    runid = 'N5_3pt'
    modid = ''
    
    prob=Problem()
    prob.model=DriveSE(debug=debug, number_of_main_bearings=1, topLevelFlag=True)
    prob.setup()
    #view_connections(prob.model, show_browser=True)

    prob['drivetrain_design']='geared'
    prob['gear_configuration']='eep'  # epicyclic-epicyclic-parallel
    prob['mb1Type']='SRB'
    prob['IEC_Class']='B'
    prob['shaft_factor']='normal'
    prob['uptower_transformer']=True
    prob['crane']=True  # onboard crane present
    prob['yaw_motors_number'] = 0 # default value - will be internally calculated
    prob['number_of_blades'] = 3
    
    # Rotor and load inputs
    prob['rotor_diameter'] = 126.0  # m
    prob['rotor_rpm'] = 12.1  # rpm m/s
    prob['tilt'] = 5.0 # deg
    prob['machine_rating'] = 5000.0
    prob['gearbox_efficiency']   = 0.975
    prob['generator_efficiency'] = 0.975
    prob['rotor_torque'] = 1.5 * (prob['machine_rating'] * 1000 / (prob['gearbox_efficiency'] * prob['generator_efficiency'])) \
                              / (prob['rotor_rpm'] * (np.pi / 30))
    #prob['rotor_thrust'] = 599610.0  # N
    prob['rotor_mass'] = 0.0  # accounted for in F_z # kg
    prob['Mxyz'] = np.array([330770.0, -16665000.0, 2896300.0])  # Nm
    prob['Fxyz'] = np.array([ 599610.0, 186780.0, -842710.0])  # N

    # Drivetrain inputs
    prob['machine_rating'] = 5000.0  # kW
    prob['gear_ratio'] = 96.76  # 97:1 as listed in the 5 MW reference document
    prob['shaft_angle'] = 5.0*np.pi / 180.0  # rad
    prob['shaft_ratio'] = 0.10 # 0.10 may be a bit small!
    prob['planet_numbers'] = [3, 3, 1]
    prob['shrink_disc_mass'] = 333.3 * prob['machine_rating'] / 1000.0  # estimated
    prob['carrier_mass'] = 8000.0  # estimated
    #prob['flange_length'] = 0.5
    prob['overhang'] = 5.0
    prob['distance_hub2mb'] = 1.912  # length from hub center to main bearing, leave zero if unknown
    prob['gearbox_input_xcm'] = 0.1
    prob['hss_input_length'] = 1.5

    # NREL 5MW properties from RotorSE
    prob['blade_mass'] = 16539.70885528
    prob['blade_root_diameter'] = 2.5
    prob['blade_length'] = 60.0
    prob['blades_I'] = np.array([37125777.37275547, 17852835.54452561, 14672945.83129043, 0.0, 0.0, 0.0])
    
    
    prob['hub_flange_thickness'] = 0
    
    # Tower inputs
    prob['tower_top_diameter'] = 3.78  # m

    # test cases
    #prob['rotor_mass'] = 1000; modid = '_r1k'
    
    prob.run_driver()
    prob.model.list_inputs(units=True)#values = False, hierarchical=False)
    prob.model.list_outputs(units=True)#values = False, hierarchical=False)    

    return prob
